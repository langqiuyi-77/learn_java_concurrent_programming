# 线程安全性

> 学习目标：了解什么是线程安全，为什么会有线程安全，如何解决线程安全；陈述性知识，偏整理清除结构

## 是什么

可知，对于写多线程程序我们所谈论的就是对锁的使用，但是这只是实现是线程安全的机制；**线程安全的本质是对共享，可变状态的管理**

### 状态

状态就是存储在对象实例或者静态域中的数据

### 共享

只有当一个状态是可以被多个线程访问的时候这个状态才有必要进行线程安全保护

### 可变

只有状态可变的时候才能出现线程问题

```
无状态的对象是线程安全的
```

## 为什么

从定义上我们看见`线程安全的本质是对共享，可变状态的管理`；那么为什么线程不安全只存在在状态是共享和可变的情况下呢？

### 竞态条件

这就要讲到线程不安全的情况是什么，当我我们是只有一个线程的时候，代码的执行都是串行的，而当我们使用多线程的时候，执行的时序是不能确定的，由此种不恰当的时序造成的不正确就是竞态条件。

通常情况下竞态条件有两种情况：先判断后执行和读取-修改-写入。先判断后执行参加的情景有延迟初始化，在需要的时候才对对象进行初始化。整个代码分为两块，先是`if()`的判断然后是对初始话的执行，分成了两个部分就可能会造成，线程A检查发现当前没有初始化，但当完成了判断即将进入初始化的代码时突然切换到线程B，线程B同样发现此时没有完成初始化，所以进行初始化并且完成初始化，在完成后转回线程A，这个时候线程A会再次进行初始化，这就造成了操作重复；而对于读取-修改-写入常见的情景就是i++问题，首先i=0;线程A读取到i=0然后在准备进行修改的时候/修改完成但在写入之前，线程B进入同样读取到i=0进行完+1的操作并写入，这时A再执行，i写入1；所以多线程问题可能会出现在虽然是进行了2次的++操作但i最后只是被加了一次;

我认为出现这些线程安全问题的本质就在于***因为多线程的加入造成上一步所观察到的状态失效***。

那么由此我们就可以解决说为什么线程安全的本质是对共享的可变的状态的管理；如果都不可变那么状态不可能失效，如果不存在共享那么也不存在状态失效，因为只有“我”能让状态变化，没有其他因素。

## 解决方法

其实本质上对线程安全，我们要做的就是防止在完成操作之前状态失效，由此我们提出了原子性；如果需要访问相同的共享变量的多个线程之间，如果有一个线程在访问那么另外的线程要么以及访问过要么没有访问的话，这样的操作就是具有原子性的.

我们有不同的方式来实现操作的原子性

### 原子类

在`java.unit.concurrent.atomic`包中有原子类,这些原子类所提供的操作都是具有原子性的是线程安全对象；原子类就能控制每一次对其的访问只有一个线程，从而实现防止状态时效，典型的问题：i++问题

```
一个无状态的对象如果加了一个状态，并且这个状态是有线程安全的对象锁管理的那么这个对象依旧是线程安全的；
```

### 加锁机制

那么既然我们有原子类那么是不是我们把所有的共享变量都使用线程安全对象来管理整个程序就是线程安全的呢？当然不是。

**我们还得维护状态之间的约束性**; 就像一个对象中存储着当前的index而value存储着当前index的val值; index和value之间是有着对应的约束; 就算我们将index和value分别使用线程安全对象来管理我们依旧可能造成index和value之间的约束造成破坏导致线程安全性不再满足。

而这个时候加锁机制就能允许我们在访问一个状态的时候同时可以随着将其有约束关系的状态进行修改(原子操作)从而实现线程安全;

#### 内置锁

在java中最常见的就是内置锁使用synchronized关键字；在java中为了方便实现有每一个对象都有一个内置锁; 但这只是为了方便使用，你同样可以自己创建锁来维护你的程序。

java中的内置锁是一个**互斥锁**; 这意味着每次只有一个线程拿到该对象的锁，如果这个线程不释放这个锁那么其他的线程就没有办法拿到。

内置锁可以帮助锁住一个代码块，在这个代码快中我们来实现对多个状态的同步

##### 重入

java的内置锁是允许重入的；重入是什么？

```java
class A{
    public synchronized methodA(){
        ...
    }
}

class B extends A{
    public synchronized methodA(){
        ...
        super.methodA();
    }
}
```

如果锁是不可重入的那么这里就会出现一个死锁；而当允许重入的时候线程得到了一个对象的锁那他就可以进入这个对象多次

其实现机制是使用一个count和记录得到锁的线程；当count为0的时候表示没有线程得到锁，线程得到锁之后会将count++并且记录线程；之后每次重入的时候会将count++每一次退出的时候就会将count--直到为0的时候就是说线程释放锁了

```
当使用加锁的时候，对同一个共享变量的所有代码都要使用锁，并且锁的对象要是同一个
```

![picture 1](images/02_%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/IMG_20221111-131258819.png)  
